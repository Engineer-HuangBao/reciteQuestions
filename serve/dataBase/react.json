{"title":"备注注解","name":"React","key":"react","data":[{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue2与vue3有什么区别","key":"react1","answer":"1.底层原理变了.\n //- V2x是通过es5的objet.definePropert对单个属性进行劫持与发布\n //- V3x是通过es6的proxy对整个对象进行拦截监听\n2.数据观察机制.\n //- V2x原理会对所有数据添加劫持发布,数据量越大,性能消耗及越多\n //- V3x只会对‘被用于渲染初始可见部分的数据’添加观察渣,从而减少性能损耗\n3.更精准的变更通知.\n //- V2x使用$set('')添加数据时会把所有的watcher（观察者）都重新运行\n //- V3x只有依赖那个属性的watcher才会重新运行"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"object.definerProperty是什么, proxy又是什么","key":"react2","answer":"1.object.definerProperty是es5对于对象设置属性的方法.\n //- Object.defineProperties('对象函数', '对象名', 声明属性(objet))\n //- 声明属性的值为-value(值)-writable(是否可修改/boolean)-enumerable(是否可遍历/boolean)-configurable(是否可修改属性或删除/boolean)-set(值被设置回调/function)-get(值被调取回调/function)\n2.proxy是es6用于在对象外层搭建拦截的方法,外界操作对象都会触发\n //- proxy('对象函数', 声明属性(拦截行为/objet))\n //- 例: var bao = new Proxy({ name: '宝' }, { get: function (target, key) { return target[key] }, set..... })\n //- 例: console.log(bao.name) ---- 打印(会触发声明的get回调): 宝"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"为什么vue3用了proxy性能会更好","key":"react3","answer":"//- 结合本文- vue2与vue3有什么区别 -与- object.definerProperty是什么, proxy又是什么 -\n//- 可知V2x是给每一个属性单独添加事件监听及发布(数据量多/嵌套,单线程处理便久),而V3x使用的是es6提供的对象外层拦截.\n//- 这里需要注意的一点是数据量非常少时,object.definerProperty的性能是优于proxy的.这里可百度查询相关文章."},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"什么是插槽, 什么是插槽作用域","key":"react4","answer":"1.插槽及是在子组件使用父组件声明好的任何模板代码\n //- 使用思路: 当创建一个组件时,组件内容可能因为个性化的问题(父组件)而需要展现不同的内容(包括样式).当不可控较多时,可回抛给使用者(父组件)处理\n //- 例-组件: <slot name=\"bao\" :item=\"item\">这里可作为默认内容,未被父组件(使用者)调用即显示默认内容</slot>  // name: 可通过名字来指定插入位置以及其值; item: 声明传值及参数; 注意: 2.6x版本v-slot可使用简写'#'(可官网查看)\n //- 例-使用者: <div slot=\"bao\" slot-scope=\"{item}\">{{ item.xxx }}</div>  // slot-scope: 接收参数合计(object)\n2.插槽作用域?引官网一句话:父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n //- 当你在父组件(调用者)使用了插槽,需要用到如v-for出来的值必须通过slot-scope回抛,不可直接使用子组件的值.如上例子"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"父子通讯有哪些方法","key":"react5","answer":"1.vuex-公共仓库\n2.props/emit // 父 <-> 子\n //- props是子组件接收父组件的传参\n //- emit是父组件接收子组件的回调\n3.attrs/listeners // 父 -> 子 -> 可继续延伸 (延伸每代都需声明)\n //- 需要2.4及以后版本,attrs/listeners使用环境为需要跨越多层组件通讯时\n //- v-bind=\"$attrs\"是参数,v-on=\"$listeners\"是方法.他们都可以将使用者传给他们所有的参数或者方法传给下一代\n //- 例-a组件: <b :value1='value1' :value2='value2' @baoOn1=\"baoOn1\" @baoOn2=\"baoOn2\" />\n //- 例-b组件: <c v-bind=\"$attrs\" v-on=\"$listeners\" />\n //- 例-c组件: <button @click=\"$listeners.baoOn1($attrs.value1 + $attrs.value2)\" />\n4.中央事件总线 // 声明$on者(组件) <- 使用$emit者(组件)\n //- 及是在new Vue上再挂载个Vue.\n //- 列: Vue.prototype.$baoVue = new Vue(); // 挂载全局 this.$baoVue.....\n //- 例2: import baoVue from 'eventBus.js'; // 注意:a-b组件要引同一个\n //- 例2-a组件: baoVue.$emit(\"getTarget\", 22); // 触发挂载方法\n //- 例2-b组件: baoVue.$on('getTarget', this.function方法); // 挂载方法; baoVue.$off(....) - 销毁\n5.provide/inject // 父 -> 子子孙孙(可跨代,需要用到的地方使用inject即可)\n //- 由调用者(或根组件)声明赋值好本组件this指向\n //- 例-根: provide( return { _this: this } )\n //- 例-后代: inject: ['_this']; // 直接 this._this.xxxx即可\n6.parent/children\n //- parent直接获取父组件实例\n //- children直接获取子组件实例(对象)\n7.ref"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue有哪些API","key":"react6","answer":"1.extend // 使用基础 Vue 构造器，创建一个“子类”\n2.nextTick // 在下次 DOM 更新循环结束之后执行延迟回调\n3.set // 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新\n4.delete // 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图\n5.directive // 注册或获取全局指令。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue指令大概有多少个,分别是什么","key":"react7","answer":"1.v-if\n2.v-else\n3.v-show\n4.v-for\n5.v-on\n6.v-model\n7.v-bind\n8.v-text \n9.v-html\n10.v-pre\n11.v-once\n12.v-cloak"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"常用属性","key":"react8","answer":"data // Vue 实例的数据对象。Vue 会递归地把 data 的 property 转换为 getter/setter\ncomputed // 计算属性 - 监听 - 当该函数里当依赖值变动时触发并返回\nwatch // 属性监听 - 及监听data里面或props值的变动 - 可监听数组_链式表达\nprops // props 可以是数组或对象，用于接收来自父组件的数据。\nmethods // 自定义函数体\ndirectives //自定义挂载属性"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"生命树","key":"react9","answer":"beforeCreate // 创建前 - 进场\ncreated // 创建后 - 构建data数据后\nbeforeMount // 挂载前 - 即将挂载dom树\nmounted // 挂载后 - dom树挂载完成后\nbeforeUpdate // 更新前 - 准备更新dom树\nupdated // 更新后 - 页面已经被刷新\nbeforeDestroy // 销毁前 - 即将销毁离开\ndestroyed // 销毁后 - 已经销毁离开"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue-router有哪几种导航钩子","key":"react10","answer":"第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截\n第二种：组件内的钩子\n第三种：单独路由独享组件"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"全局api","key":"react11","answer":"Vue.extend // 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\nVue.nextTick // 在下次 DOM 更新循环结束之后执行延迟回调\nVue.set // 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的\nVue.delete // 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图\nVue.directive // 注册或获取全局指令。\nVue.filter // 注册或获取全局过滤器。\nVue.component // 注册或获取全局组件。注册还会自动使用给定的 id 设置组件的名称\nVue.use // 安装 Vue.js 插件,如果插件是一个对象，必须提供 install 方法。\nVue.mixin // 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。\nVue.compile // 将一个模板字符串编译成 render 函数。只在完整版时可用。\nVue.observable // 2.6+ 让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。\nVue.version  // 提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"路由之间是怎么转跳的","key":"react12","answer":"router.push('/home') // js\n1，<router-link to='home' /> // router-link标签会渲染为<a>标签，咋填template中的跳转都是这种；"}],"isChoice":false}