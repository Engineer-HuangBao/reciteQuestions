{"title":"备注注解","name":"Vue","key":"vue","data":[{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 如何再Vue的单文件组件里的样式定义全局CSS？","key":"vue1","answer":"- 在style标签上不加上scoped的属性，默认为全局css样式"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★ vue-router 3.1.0 <router-link>新增的v-slot属性怎么用？","key":"vue2","answer":"router-link 通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 API，主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似 NavLink 这样的自定义组件里。\n\n在使用 v-slot API 时，需要向 router-link 传入一个单独的子元素。否则 router-link 将会把子元素包裹在一个 span 元素内。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 如何实现一个路径渲染多个组件？","key":"vue3","answer":"- 可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。通过设置components即可同时渲染多个组件。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 如何实现多个路径共享一个组件？","key":"vue4","answer":"- 只需将多个路径的component字段的值设置为同一个组件即可。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★★ 如何监测动态路由的变化","key":"vue5","answer":"- 可以通过watch方法来对$route进行监听，或者通过导航守卫的钩子函数beforeRouteUpdate来监听它的变化。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 对MVC，MVP，MVVM的理解","key":"vue6","answer":"mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。\n\nMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。\n1：Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n2：在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\n3：ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 说一下$root，$parent，$refs","key":"vue7","answer":"$root，和$parent都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过parent 访问得到的是它最近一级的父组件，通过root 访问得到的是根父组件。通过在子组件标签定义 ref 属性，在父组件中可以使用$refs 访问子组件实例。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★★ 你知道Vue响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？","key":"vue8","answer":"// 响应式原理\n\nvue的响应式实现主要是利用了Object.defineProperty的方法里面的setter 与getter方法的观察者模式来实现。在组件初始化时会给每一个data属性注册getter和setter，然后再new 一个自己的Watcher对象，此时watcher会立即调用组件的render函数去生成虚拟DOM。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的Watcher函数注册进sub里。当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。\n\n// proxy的优势如下：\n\nProxy 可以直接监听对象而非属性，可以直接监听数组的变化；\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；\n\n\n// Object.defineProperty 的优势如下:\n\n兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill(垫片)来弥补"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ Composition API 的出现带来哪些新的开发体验，为啥需要这个？","key":"vue9","answer":"1：在Compostion API 中时根据逻辑相关组织代码的，提高可读性和可维护性，类似于react的hook写法。\n2：更好的重用逻辑代码，在Options API中通过MIxins重用逻辑代码，容易发生命名冲突且关系不清。\n3：解决在生命周期函数经常包含不相关的逻辑，但又不得不把相关逻辑分离到了几个不同方法中的问题，如在mounted中设置定时器，但需要在destroyed中来清除定时器，将同一功能的代码拆分到不同的位置，造成后期代码维护的困难。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 什么情况下使用 Vuex","key":"vue10","answer":"- 如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可，需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vuex可以直接修改state的值吗？","key":"vue11","answer":"- 可以直接修改，但是极其不推荐，state的修改必须在mutation来修改，否则无法被devtool所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游/回滚之类的操作。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ 为什么Vuex的mutation不能做异步操作","key":"vue12","answer":"Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，否则无法被devtools所监测。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"vue13","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 解释单向数据流和双向数据绑定","key":"vue14","answer":"对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。\n\n而双向数据绑定即为当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，两个数据流之间互为影响。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ Vue 如何去除url中的 #","key":"vue15","answer":"将路由模式改为history"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"vue16","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ $route 和 $router 的区别","key":"vue17","answer":"$route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom等。而$router主要是用来操作路由的，它是VueRouter的实例，包含了一些路由的跳转方法，钩子函数等"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 对比 jQuery，Vue 有什么不同","key":"vue18","answer":"jQuery 专注视图层，通过直接操作 DOM 去实现页面的一些逻辑渲染；Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作。Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★★ Vue 中怎么自定义指令","key":"vue19","answer":"通过directive来自定义指令，自定义指令分为全局指令和局部指令，自定义指令也有几个的钩子函数，常用的有bind和update，当 bind 和 update 时触发相同行为，而不关心其它的钩子时可以简写。一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vue 中怎么自定义过滤器","key":"vue20","answer":"通过filter来定义过滤器，过滤器分为全局和局部过滤器，过滤器的主体为一个普通的函数，来对数据进行处理，可以传递参数。当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vue 等单页面应用的优缺点","key":"vue21","answer":"// 优点\n1单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。\n\n2、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象\n\n3、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。\n\n4、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。\n\n// 缺点\n1、首次加载耗时比较多。\n\n2、SEO问题，不利于百度，360等搜索引擎收录。\n\n3、容易造成Css命名冲突。\n\n4、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vue-router 使用params与query传参有什么区别","key":"vue22","answer":"// 用法上\n1：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。\n\n// 展示上\n2：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示\n\n3：params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。\n4：params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vue中 keep-alive 的作用","key":"vue23","answer":"keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用keepalive包裹组件，此时mouted，created等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，actived和deactived，这两个钩子函数只有被keepalive包裹后才会调用。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vue如何实现单页面应用","key":"vue24","answer":"通常的url 地址由以下内容构成：协议名 域名 端口号 路径 参数 哈希值，当哈希值改变，页面不会发生跳转，单页面应用就是利用了这一点，给window注册onhashchange事件，当哈希值改变时通过location.hash就能获得相应的哈希值，然后就能跳到相应的页面。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"vue25","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 说出至少4种Vue当中的指令和它的用法？","key":"vue26","answer":"v-if(判断是否隐藏，用来判断元素是否创建)\nv-show(元素的显示隐藏，类似css中的display的block和hidden)\nv-for(把数据遍历出来)\nv-bind(绑定属性)\nv-model(实现双向绑定)"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"vue27","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"vue28","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vue-loader解释一下","key":"vue29","answer":"- 解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"vue30","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 用过插槽吗？用的是具名插槽还是匿名插槽","key":"vue31","answer":"用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一一对应。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"vue32","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Vue 路由守卫","key":"vue33","answer":"vue-router 提供的导航守卫主要用来对路由的跳转进行监控，控制它的跳转或取消，路由守卫有全局的, 单个路由独享的, 或者组件级的。导航钩子有3个参数：\n\n1、to:即将要进入的目标路由对象；\n2、from:当前导航即将要离开的路由对象；\n3、next ：调用该方法后，才能进入下一个钩子函数（afterEach）。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★ Vue中如何实现子组件内的css样式名在项目中绝对唯一性","key":"vue34","answer":"- 在style标签上加上scoped属性"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★★ Vue3中的双向数据绑定proxy","key":"vue35","answer":"- Proxy相当于在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是Object.defineProperty的全方位加强版，它解决了之前defineProperty无法监听到数组变化等缺点。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★★ Vue和React中diff算法区别","key":"vue36","answer":"vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。\n\n1.vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。\n\n2.vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 请你说一下 Vue 中 create 和 mount 的区别","key":"vue37","answer":"create为组件初始化阶段，在此阶段主要完成数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，此时还未生成真实的DOM，也就无法获取和操作DOM元素。而mount主要完成从虚拟DOM到真实DOM的转换挂载，此时html已经渲染出来了，所以可以直接操作dom节点。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ Object.defineProperty有什么缺点","key":"vue38","answer":"1：无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；\n2：只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ axios是什么？怎么使用？描述使用它实现登录功能的流程?","key":"vue39","answer":"- axios 是请求后台资源的模块。 通过npm install axios -S来安装，在大多数情况下我们需要封装拦截器，在实现登录的过程中我们一般在请求拦截器中来加入token，在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中 config/index.js 进行代理配置。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ v-model是什么？Vue中标签怎么绑定事件？","key":"vue40","answer":"v-model是一个语法糖，这一个指令可以分为几个指令，它内部已经帮我们处理整合了。对于普通的文本框来说，v-model = v-bind:value + @input。对单选框和复选框来说，v-model = v-bind:checked + @change，并且它还有一个非常重要的功能，就是解决父子组件之间的通讯问题，可以提升我们的开发效率。在vue中通过使用<v-on:事件名 = 函数名>的方式来绑定事件。"}],"isChoice":false}