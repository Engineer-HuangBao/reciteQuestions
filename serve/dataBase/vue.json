{"title":"备注注解","name":"Vue","key":"vue","data":[{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue2与vue3有什么区别","key":"vue1","answer":"1.底层原理变了.\n //- V2x是通过es5的objet.definePropert对单个属性进行劫持与发布\n //- V3x是通过es6的proxy对整个对象进行拦截监听\n2.数据观察机制.\n //- V2x原理会对所有数据添加劫持发布,数据量越大,性能消耗及越多\n //- V3x只会对‘被用于渲染初始可见部分的数据’添加观察渣,从而减少性能损耗\n3.更精准的变更通知.\n //- V2x使用$set('')添加数据时会把所有的watcher（观察者）都重新运行\n //- V3x只有依赖那个属性的watcher才会重新运行"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"object.definerProperty是什么, proxy又是什么","key":"vue2","answer":"1.object.definerProperty是es5对于对象设置属性的方法.\n //- Object.defineProperties('对象函数', '对象名', 声明属性(objet))\n //- 声明属性的值为-value(值)-writable(是否可修改/boolean)-enumerable(是否可遍历/boolean)-configurable(是否可修改属性或删除/boolean)-set(值被设置回调/function)-get(值被调取回调/function)\n2.proxy是es6用于在对象外层搭建拦截的方法,外界操作对象都会触发\n //- proxy('对象函数', 声明属性(拦截行为/objet))\n //- 例: var bao = new Proxy({ name: '宝' }, { get: function (target, key) { return target[key] }, set..... })\n //- 例: console.log(bao.name) ---- 打印(会触发声明的get回调): 宝"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"为什么vue3用了proxy性能会更好","key":"vue3","answer":"//- 结合本文- vue2与vue3有什么区别 -与- object.definerProperty是什么, proxy又是什么 -\n//- 可知V2x是给每一个属性单独添加事件监听及发布(数据量多/嵌套,单线程处理便久),而V3x使用的是es6提供的对象外层拦截.\n//- 这里需要注意的一点是数据量非常少时,object.definerProperty的性能是优于proxy的.这里可百度查询相关文章."},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"什么是插槽, 什么是插槽作用域","key":"vue4","answer":"1.插槽及是在子组件使用父组件声明好的任何模板代码\n //- 使用思路: 当创建一个组件时,组件内容可能因为个性化的问题(父组件)而需要展现不同的内容(包括样式).当不可控较多时,可回抛给使用者(父组件)处理\n //- 例-组件: <slot name=\"bao\" :item=\"item\">这里可作为默认内容,未被父组件(使用者)调用即显示默认内容</slot>  // name: 可通过名字来指定插入位置以及其值; item: 声明传值及参数; 注意: 2.6x版本v-slot可使用简写'#'(可官网查看)\n //- 例-使用者: <div slot=\"bao\" slot-scope=\"{item}\">{{ item.xxx }}</div>  // slot-scope: 接收参数合计(object)\n2.插槽作用域?引官网一句话:父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n //- 当你在父组件(调用者)使用了插槽,需要用到如v-for出来的值必须通过slot-scope回抛,不可直接使用子组件的值.如上例子"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"父子通讯有哪些方法","key":"vue5","answer":"1.vuex-公共仓库\n2.props/emit // 父 <-> 子\n //- props是子组件接收父组件的传参\n //- emit是父组件接收子组件的回调\n3.attrs/listeners // 父 -> 子 -> 可继续延伸 (延伸每代都需声明)\n //- 需要2.4及以后版本,attrs/listeners使用环境为需要跨越多层组件通讯时\n //- v-bind=\"$attrs\"是参数,v-on=\"$listeners\"是方法.他们都可以将使用者传给他们所有的参数或者方法传给下一代\n //- 例-a组件: <b :value1='value1' :value2='value2' @baoOn1=\"baoOn1\" @baoOn2=\"baoOn2\" />\n //- 例-b组件: <c v-bind=\"$attrs\" v-on=\"$listeners\" />\n //- 例-c组件: <button @click=\"$listeners.baoOn1($attrs.value1 + $attrs.value2)\" />\n4.中央事件总线 // 声明$on者(组件) <- 使用$emit者(组件)\n //- 及是在new Vue上再挂载个Vue.\n //- 列: Vue.prototype.$baoVue = new Vue(); // 挂载全局 this.$baoVue.....\n //- 例2: import baoVue from 'eventBus.js'; // 注意:a-b组件要引同一个\n //- 例2-a组件: baoVue.$emit(\"getTarget\", 22); // 触发挂载方法\n //- 例2-b组件: baoVue.$on('getTarget', this.function方法); // 挂载方法; baoVue.$off(....) - 销毁\n5.provide/inject // 父 -> 子子孙孙(可跨代,需要用到的地方使用inject即可)\n //- 由调用者(或根组件)声明赋值好本组件this指向\n //- 例-根: provide( return { _this: this } )\n //- 例-后代: inject: ['_this']; // 直接 this._this.xxxx即可\n6.parent/children\n //- parent直接获取父组件实例\n //- children直接获取子组件实例(对象)\n7.ref"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue有哪些API","key":"vue6","answer":"1.extend // 使用基础 Vue 构造器，创建一个“子类”\n2.nextTick // 在下次 DOM 更新循环结束之后执行延迟回调\n3.set // 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新\n4.delete // 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图\n5.directive // 注册或获取全局指令。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue指令大概有多少个,分别是什么","key":"vue7","answer":"1.v-if\n2.v-else\n3.v-show\n4.v-for\n5.v-on\n6.v-model\n7.v-bind\n8.v-text \n9.v-html\n10.v-pre\n11.v-once\n12.v-cloak"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"常用属性","key":"vue8","answer":"data // Vue 实例的数据对象。Vue 会递归地把 data 的 property 转换为 getter/setter\ncomputed // 计算属性 - 监听 - 当该函数里当依赖值变动时触发并返回\nwatch // 属性监听 - 及监听data里面或props值的变动 - 可监听数组_链式表达\nprops // props 可以是数组或对象，用于接收来自父组件的数据。\nmethods // 自定义函数体\ndirectives //自定义挂载属性"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"生命树","key":"vue9","answer":"beforeCreate // 创建前 - 进场\ncreated // 创建后 - 构建data数据后\nbeforeMount // 挂载前 - 即将挂载dom树\nmounted // 挂载后 - dom树挂载完成后\nbeforeUpdate // 更新前 - 准备更新dom树\nupdated // 更新后 - 页面已经被刷新\nbeforeDestroy // 销毁前 - 即将销毁离开\ndestroyed // 销毁后 - 已经销毁离开"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue-router有哪几种导航钩子","key":"vue10","answer":"第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截\n第二种：组件内的钩子\n第三种：单独路由独享组件"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"全局api","key":"vue11","answer":"Vue.extend // 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\nVue.nextTick // 在下次 DOM 更新循环结束之后执行延迟回调\nVue.set // 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的\nVue.delete // 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图\nVue.directive // 注册或获取全局指令。\nVue.filter // 注册或获取全局过滤器。\nVue.component // 注册或获取全局组件。注册还会自动使用给定的 id 设置组件的名称\nVue.use // 安装 Vue.js 插件,如果插件是一个对象，必须提供 install 方法。\nVue.mixin // 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。\nVue.compile // 将一个模板字符串编译成 render 函数。只在完整版时可用。\nVue.observable // 2.6+ 让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。\nVue.version  // 提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"路由之间是怎么转跳的","key":"vue12","answer":"router.push('/home') // js\n1，<router-link to='home' /> // router-link标签会渲染为<a>标签，咋填template中的跳转都是这种；"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"有使用过 Vue 吗？说说你对 Vue 的理解","key":"vue13","answer":"Vue 是一个构建数据驱动的渐进性框架，它的目标是通过 API 实现响应数据绑定和视 图更新\n- 渐进性框架 -\n 可以在边开发中边学习，简单的基础知识即可书写项目，后续可陆续学习使用。\n- api -\n 声明好的使用指令。\n\n"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"vue的原理是什么，MVC 与 MVVM 有什么区别","key":"vue14","answer":"1.Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值 (set)。\n- Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责 在数据库中存取数据\n- View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。\n- Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"diff 算法是什么","key":"vue15","answer":"diff 算法是指对新旧虚拟节点进行对比，并返回一个 patch 对象，用来存储两个节点 不同的地方，最后利用 patch 记录的消息局部更新 DOM"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"虚拟 DOM 的优缺点","key":"vue16","answer":"- 缺点 -\n · 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢\n- 优点- \n · 减少了 dom 操作，减少了回流与重绘 保证性能的下限，虽说性能不是最佳，但是它具备局部更新的能力，所以大部分时候 还是比正常的 DOM 性能高 \n   很多的"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"说说 Vue 的优缺点","key":"vue17","answer":"- 优点 -\n  1、数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象）， 并配合 diff 算法、响应式和观察者、异步队列等手段以最 \n     小代价更新 dom，渲染页面\n  2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编 写 html\\css（scoped 属性配置 css 隔离）\\js 并且配合 \n     Vue-loader 之后，支持更强 大的预处理器等功能 \n  3、强大且丰富的 API 提供一系列的 api 能满足业务开发中各类需求\n  4、由于采用虚拟 dom，让 Vue ssr 先天就足\n  5、生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有优化 空间（Vue3 composition-api）\n  6、生态好，社区活跃\n- 缺点 -\n  1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持 IE8 及 以下浏览器 \n  2、csr 的先天不足，首屏性能问题（白屏）\n  3、由于百度等搜索引擎爬虫无法爬取 js 中的内容，故 spa 先天就对 seo 优化心有余 力不足（谷歌的 puppeteer 就挺牛逼的，实现预渲染底层 \n     也是用到了这个工具）\n"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"Vue 和 React 有什么不同？使用场景分别是什么？","key":"vue18","answer":"1、Vue 是完整一套由官方维护的框架，核心库主要有由尤雨溪大神独自维护，而 React 是不要脸的书维护（很多库由社区维护），曾经一段时间很多人质 \n   疑 Vue 的后 续维护性， 似乎这并不是问题。\n2、Vue 上手简单，进阶式框架，白话说你可以学一点，就可以在你项目中去用一点， 你不一定需要一次性学习整个 Vue 才能去使用它，而 React，恐怕 \n   如果你这样会面对 项目束手无策。\n3、语法上 Vue 并不限制你必须 es6+完全 js 形式编写页面，可以视图和 js 逻辑尽可 能分离，减少很多人看不惯 React-jsx 的恶心嵌套，毕竟都 \n   是作为前端开发者，还是 更习惯于 html 干净。\n4、很多人说 React 适合大型项目，适合什么什么，Vue 轻量级，适合移动端中小型 项目，其实 Vue 完全可以应对复杂的大型应用，甚至于说如果你 \n   React 学的不是很好， 写出来的东西或根本不如 Vue 写的，毕竟 Vue 跟着官方文档撸就行，自有人帮你规 范，而 React 比较懒散自由，可以自 \n   由发挥\n5、Vue 在国内人气明显胜过 React，这很大程度上得益于它的很多语法包括编程思维 更符合国人思想。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" 什么是虚拟 DOM？","key":"vue19","answer":"虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在 react，vue 等技术出现之 前， 我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然 后修改样式行为或者结构，来达到更新 ui 的目的。 这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果 建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" watch 怎么深度监听对象变化","key":"vue20","answer":"- deep 设置为 true 就可以监听到对象的变化 -\nxxxx: {\n  deep: true,\n  handler: function (value) { }\n},"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"删除数组用 delete 和 Vue.delete 有什么区别？","key":"vue21","answer":"- delete -\n  只是被删除数组成员变为 empty / undefined，其他元素键值不变\n- Vue.delete -\n  直接删了数组成员，并改变了数组的键值（对象是响应式的，确保删除 能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制）"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"说说 Vue React angularjs jquery 的区别","key":"vue22","answer":"- JQuery 与另外几者最大的区别是，JQuery 是事件驱动，其他两者是数据驱动,JQuery 业务逻辑和 UI 更改该混在一起， UI 里面还参杂这交互逻辑，让本来混乱的 逻辑更加混乱。\n- Angular，Vue 是双向绑定，而"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？","key":"vue23","answer":"- 响应式优化 - \n  defineProperty API 的局限性最大原因是它只能针对单例属性做监听。 Vue2.x 中的响应式实现正是基于 defineProperty 中 \n  的descriptor，对 data 中的属 性做了遍历 + 递归，为每个属性设置了 getter、setter。 这也就是为什么 Vue 只能对 data   \n  中预定义过的属性做出响应的原因，在 Vue 中使用 下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 \n  setter 监听的，这是 defineProperty 的局限性。 \n- Proxy API -\n  它的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操 作，这就完全可以代理所有属性，将会带来很大的性能提升和 \n  更。优的代码。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必 须先通过这层拦截，因此提供了一 \n  种机制，可以对外界的访问进行过滤和改写。 \n- 响应式是惰性 -\n  在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需 要递归遍历这个对象，执行 \n  Object.defineProperty 把每一层对象数据都变成响应式 的，这无疑会有很大的性能消耗。 在 Vue.js 3.0 中，使用 Proxy \n  API 并不能监听到对象内部深层次的属性变化，因此它 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属 \n  性才会变 成响应式，简单的可以说是按需实现响应式，减少性能消耗。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"Vue3.0 编译做了哪些优化","key":"vue24","answer":"- 生 成 Block tree Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部需要遍历该 组件的整个 vnode 树。 \n  在2.0 里，渲染效率的快慢与组件大小成正相关：组件越大， 渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是 \n  性能浪费。 Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。 Block tree 是一个将模版基于动态 \n  节点指令切割的嵌套区块，每个区块内部的节点结构是固定的， 每个区块只需要追踪自身包含的动态节点。所以，在 3.0 里，渲染效 \n  率再与模板大 小成正相关，而是与模板中动态节点的数量成正相关。 \n- slot 编译优化 Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使 子组件 update，造成性能 \n  的浪费。 Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更新。 动态 slot 指的是在 \n  slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产生运行 时动态变化但是又无法被子组件 track 的操作。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"Vue3.0 是如何变得更快的？（底层，源码）","key":"vue25","answer":"- diff 方法优化 Vue2.x 中的虚拟 dom 是进行全量的对比。 Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比 \n  的时候，只对 比带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容 化。 hoistStatic 静态提 \n  升 Vue2.x : 无论元素是否参与更新，每次都会重新创建。 Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候 \n  被不停的复 用。\n- cacheHandlers 事件侦听器缓存 默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同 一个函数，所 \n  以没有追踪变化，直接缓存起来复用即可。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"Vue3.0 新特性 —— Composition API 与 React.js 中 Hooks 的异同点","key":"vue26","answer":"- React.js 中的 Hooks 基本使用 React Hooks 允许你 \"勾入\" 诸如组件状态和副作用处理等 React 功能中。Hooks 只 能用在 函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多 东西带入组件中。 React 核心团队奉上的采纳策略是不 反对类组件，所以你可以升级 React 版本、在新 组件中开始尝试 Hooks，并保持既有组件不做任何更改。useState 和useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状 态和运行副作用。 我们也可以自定义一个 。Hooks，  它打开了代码复用性和扩展性的新大门。\n- Vue Composition API 基本使用 Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件 提供 了状态、计算值、watcher 和生命周期钩子。 并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种API\n- 原理 - \n  React hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序 执行所有的 hooks。 Vue hook 只会被注 册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的 响应是基于 proxy 的，对数据直接代理观察。（这种场景下，只要任何一个更改 data 的地方，相关的 function 或者 template 都会被重新计算，因此避开了 React 可能遇 到的性能上的问题）。React 中，数据更改的时候，会导致重新 render，重新 render 又会重新把 hooks 重 新注册一次，所以 React 复杂程度会高一些。"}],"isChoice":true}