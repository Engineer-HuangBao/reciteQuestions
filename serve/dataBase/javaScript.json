{"title":"备注注解","name":"Javascript","key":"javaScript","data":[{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 介绍一下JS的内置类型有哪些？","key":"javaScript1","answer":"1. 空类型:null\n2. 未定义:undefined\n3. 布尔:boolean\n4. 数字:number\n5. 字符串:string\n6. 符号:symbol(ES6新增)\n7. 对象:object\n除了对象之外,其他为基本类型."},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ 介绍一下 typeof 区分类型的原理","key":"javaScript2","answer":"typeof原理： 不同的对象在底层都表示为二进制，在Javascript中二进制前（低）三位存储其类型信息。\n\n000: 对象\n010: 浮点数\n100:字符串\n110: 布尔\n1: 整数\n/*----------------------------------------------*/\ntypeof null 为\"object\", 原因是因为 不同的对象在底层都表示为二进制，在Javascript中二进制前（低）三位都为0的话会被判断为Object类型，null的二进制表示全为0，自然前三位也是0，所以执行typeof时会返回\"object\""},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 介绍一下类型转换","key":"javaScript3","answer":"/*-------------------显式转换---------------------*/\n1. toString()      // 转化为字符串，不可以转null和underfined\n2. Number()     // 转换为数字，字符串中有一个不是数值的字符，返回NaN\n3. parseInt()    // 转换为数字，第一个字符不是数字或者符号就返回NaN\n4. String()     // 转换为字符串， \n5. Boolean()     // 转换为布尔值\n/*-------------------隐式转换(+-)---------------------*/\n当 JavaScript 尝试操作一个 \"错误\" 的数据类型时，会自动转换为 \"正确\" 的数据类型\n1. num  +  \"\"  -> String\n2. num + bool -> num\n// 当加号运算符时，String和其他类型时，其他类型都会转为 String；其他情况，都转化为Number类型\n\n3. string - num -> num\n// 其他运算符时， 基本类型都转换为 Number，String类型的带有字符的比如： \n4. 'a1' - num -> NaN\n// 与undefined 一样。\n\n/*-------------------隐式转换(逻辑表达式)---------------------*/\n\n1. 对象和布尔值比较\n对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字\n[] == true;  //false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false\n2. 对象和字符串比较\n对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。\n[1,2,3] == '1,2,3' // true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;\n3. 对象和数字比较\n对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。\n[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] => '1' => 1 所以结果为true\n4. 字符串和数字比较\n字符串和数字进行比较时，字符串转换成数字，二者再比较。\n'1' == 1 // true\n5. 字符串和布尔值比较\n字符串和布尔值进行比较时，二者全部转换成数值再比较。\n'1' == true; // true \n6. 布尔值和数字比较\n布尔值和数字进行比较时，布尔转换为数字，二者比较。\ntrue == 1 // true"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ 说说你对 JavaScript 的作用域的理解。什么是作用域链？","key":"javaScript4","answer":"在 JavaScript 中有两种作用域类型：\n\n1. 局部作用域:只能在函数内部访问它们\n2. 全局作用域:网页的所有脚本和函数都能够访问它\nJavaScript 拥有函数作用域：每个函数创建一个新的作用域。\n\n作用域决定了这些变量的可访问性（可见性）。\n\n函数内部定义的变量从函数外部是不可访问的（不可见的）。\n\n作用域链：\n当查找变量的时候，会先从当前上下文的变量对象中查找，\n如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。\n这样由多个执行上下文的变量对象构成的链表就叫做作用域链"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 解释下 let 和 const 的块级作用域","key":"javaScript5","answer":"/*------------let-----------*/\n1. let声明的仅在块级作用域内有效，\n2. let不会发生变量提升的现象，所以一定要在定义后使用，否则报错。\n3. 暂时性死区：只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部影响。\n4. 不允许重复声明，let不允许在相同作用域内，重复声明同一个变量：\n/*-----------const----------*/\n1. 声明一个只读的常量。一旦声明，常量的值就不能改变。\n2. 一旦声明，就要立即初始化，否则也报错。\n3. const命令声明的常量也不提升，同样存在暂时性死区，只能在声明的位置后使用。\n4. 也不可以重复声明。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ 说说你对执行上下文的理解","key":"javaScript6","answer":"执行上下文有且只有三类，全局执行上下文，函数上下文，与eval上下文(eval一般不会使用)\n1. 全局执行上下文：\n   全局执行上下文只有一个，也就是我们熟知的window对象，我们能在全局作用域中通过this直接访问到它\n2. 函数执行上下文\n   函数执行上下文可存在无数个，每当一个函数被调用时都会创建一个函数上下文；\n   需要注意的是，同一个函数被多次调用，都会创建一个新的上下文。\n\n3. 执行上下文栈(下文简称执行栈)也叫调用栈，\n执行栈用于存储代码执行期间创建的所有上下文，具有LIFO（Last In First Out后进先出，也就是先进后出）的特性。\n\nJS代码首次运行，都会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内；由于执行栈LIFO的特性，所以可以理解为，JS代码执行完毕前在执行栈底部永远有个全局执行上下文。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 对闭包的看法，为什么要用闭包？说一下闭包的原理以及应用场景？闭包的 this 指向问题？","key":"javaScript7","answer":"闭包的作用：\n1. 在外部访问函数内部的变量\n2. 让函数内的局部变量可以一直保存下去\n3. 模块化私有属性和公共属性\n\n闭包的原理：\n全局变量生存周期是永久，局部变量生存周期随着函数的调用介绍而销毁。\n闭包就是 在函数中定义且成为该函数内部返回的函数的自由变量 的变量，该变量不会随着外部函数调用结束而销毁。 \n（注：不光是变量，函数内声明的函数也可以形成闭包）\n当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。\n\n闭包的应用场景：\n// 1. 返回值 最常见的一种形式\n\n    var fun_1 = function () {\n      var name = \"limo\";\n      return function () {      \n        return name;\n      }\n    }\n    var fun_1 = function () {\n      var name = \"limo\";\n      return name;\n    }\n    var fu_1 = fun_1();\n    console.log(\"fu_1():\" + fu_1());\n\n// 2. 函数赋值 一种变形的形式是将内部函数赋值给一个外部变量\n\n    var f2;\n    var fun_2 = function () {\n      var name = \"limop\"\n      var a = function () {\n        return name;\n      }\n      f2 = a;\n    }\n    f2();\n    console.log(f2);\n\n// 3. 函数参数 通过函数参数引用内部函数产生闭包\n\n    var fn_3 = function (f3) {\n      console.log(f3);\n    }\n\n    function fun_3() {\n      var name = \"limo\";\n      var a = function () {\n        return name;\n      }\n      fn_3(a)\n    }\n    fun_3();\n\n// 4. IIFE(自执行函数)\n\n    var fn_4 = function (f4) {\n      console.log(f4);\n    };\n    (function fun_4() {\n      var name = \"limo\";\n      var a = function () {\n        return name;\n      }\n      fn_3(a)\n    })();\n\n// 5. 循环赋值\n\n    function foo(){\n      var arr = [];\n      for(var i = 0; i < 10; i++){\n        arr[i] = (function(n){\n          return function(){\n            return n;\n          }\n        })(i)\n      }\n      return arr;\n    }\n    var bar = foo();\n    console.log(bar[3]());\n\n// 6. getter和setter\n\n    // getter和setter函数来将要操作的变量保存在函数内部，防止暴露在外部\n    var getValue, setValue;\n    (function () {\n      var num = 0\n      getValue = function () {\n        return num\n      }\n      setValue = function (v) {\n        if (typeof v === 'number') {\n          num = v\n        }\n      }\n    })();\n    console.log(getValue());    //0\n    setValue(10);\n    console.log(getValue())     //10\n\n// 7.迭代器（计数器）\n\n    var add = function(){\n      var num = 0;\n      return function(){\n        return ++num;\n      }\n    }();\n    console.log(add());\n    console.log(add());\n\n    function setUp(arr){\n      var i = 0;\n      return function(){\n        return arr[i++];\n      }\n    }\n    var next = setUp(['Steve','Alex','LingYi']);\n    console.log(next());\n    console.log(next());\n    console.log(next());\n\n// 8.触发事件\n\n    window.onload = function (){\n      var btn = document.querySelector('.btn')\n      btn.onclick = function (){//事件相当于在全局触发\n        btn.style.color = 'red'//保持对上层作用域的引用 btn\n        console.log('abc')\n        // this\n      }\n    }\n\n闭包的this指向问题：\n\nvar myNumber = {\n  value: 1,\n  add: function(i){\n    var helper = function(i){\n        console.log(this);\n          this.value += i;\n    }\n    helper(i);\n  }\n}\nmyNumber.add(1);\n1.this指向window对象（因为匿名函数的执行具有全局性，所以其this对象指向window）；\n2.不能实现value加1（每个函数在被调用时都会自动取得两个特殊变量，this和arguments，内部函数在搜索这两个对象时，只会搜索到其活动对象为止，所以不能实现访问外部函数的this对象）；\n3.修改代码实现正确功能\n\n第一种解决方法：\n\nvar myNumber={\n    value:1,\n    add:function(i){\n        var that=this;//定义变量that用于保存上层函数的this对象\n        var helper=function(i){\n             console.log(that);\n        that.value+=i;\n    }\n    helper(i);\n    }\n}\nmyNumber.add(1);\n\n第二种解决方法：\n\nvar myNumber={\n    value:1,\n    add:function(i){\n        var helper=function(i){\n            this.value+=i;\n        }\n        helper.apply(this,[i]);//使用apply改变helper的this对象指向，使其指向myNumber对象\n    }\n}\nmyNumber.add(1);\n第三种解决方法\n\nvar myNumber={\n    value:1,\n    add:function(i){\n        var helper=function(i){\n            this.value+=i;\n        }.bind(this,i);//使用bind绑定，和apply相似，只是它返回的是对函数的引用，不会立即执行\n        helper(i);\n    }\n}\nmyNumber.add(1);"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 简述闭包的问题以及优化","key":"javaScript8","answer":"闭包的缺点：占用内层空间 大量使用闭包会造成 栈溢出\n\n由于闭包会一直占用内存空间，直到页面销毁，我们可以主动将已使用的闭包销毁：\n将闭包函数赋值为null 可以销毁闭包"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 如何确定 this 指向？改变 this 指向的方式有哪些？","key":"javaScript9","answer":" this 指向：\n1. 全局上下文（函数外）\n无论是否为严格模式，均指向全局对象。注意:严格模式下全局对象为undifined\n2. 函数上下文（函数内）\n默认的，指向函数的调用对象，且是最直接的调用对象：\n简单调用，指向全局对象注意:严格模式下全局对象为undifined，某些浏览器未实现此标准也可能会是window\n\n改变this指向的方式：\n1. 第一种： new关键字改变this指向\n\n//构造函数版this\nfunction Fn(){\n    this.user = \"李某\";\n}\nvar a = new Fn();\nconsole.log(a.user); //李某\n/*----------------------------------------*/\n2. 第二种： call()\n// 把b添加到第一个参数的环境中，简单来说，this就会指向那个对象\nvar a = {\n    user:\"李某\",\n    fn:function(){\n        console.log(this.user); //李某\n    }\n}\nvar b = a.fn;\nb.call(a);  //若不用call，则b()执行后this指的是Window对象\n/*----------------------------------------*/\n3. 第三种：apply()\n// apply方法和call方法有些相似，它也可以改变this的指向，也可以有多个参数，但是不同的是，第二个参数必须是一个数组\nvar a = {\n    user:\"李某\",\n    fn:function(){\n        console.log(this.user); //李某\n    }\n}\nvar b = a.fn;\nb.apply(a);\n/*----------------------------------------*/\n4. 第四种：bind()\n// bind方法返回的是一个修改过后的函数,\n// bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。\nvar a = {\n    user:\"李某\",\n    fn:function(){\n        console.log(this.user); //李某\n    }\n}\nvar b = a.fn;\nvar c = b.bind(a);\nc();"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 介绍箭头函数的 this","key":"javaScript10","answer":"由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值\n1. 所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。\n2. 考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略\n\n作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 谈一下你对原型链的理解","key":"javaScript11","answer":"原型链:\n因为每个对象和原型都有原型，对象的原型指向原型对象，\n而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ ES5/ES6 的继承除写法以外还有什么区别？","key":"javaScript12","answer":"1. ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加 到 this 上(Parent.apply(this)).\n2. ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this(所以必 须先调用父类的super()方法)，然后再用子类的构造函数修改 this。\n3. ES5 的继承时通过原型或构造函数机制来实现。\n4. ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关 键字实现继承。\n5. 子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因 为子类没有自己的 this对象，而是继承了父类的 this 对象，然后对其进行加工。 如果不调用 super 方法，子类得不到 this 对象。\n6. 注意 super 关键字指代父类的实例，即父类的 this 对象。 注意:在子类构造函数中，调用 super 后，才可使用 this关键字，否则报错"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ 你对事件循环有了解吗？说说看","key":"javaScript13","answer":"Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下：\n\n执行栈选择最先进入队列的宏任务(通常是script整体代码)，如果有则执行\n检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列\n更新render(每一次事件循环，浏览器都可能会去更新渲染)\n重复以上步骤\n宏任务 > 所有微任务 > 宏任务\n\n\n1. 将所有任务看成两个队列：执行队列与事件队列。\n2. 执行队列是同步的，事件队列是异步的，宏任务放入事件列表，微任务放入执行队列之后，事件队列之前。\n3. 当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"javaScript14","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"--","key":"javaScript15","answer":"--"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 异步解决方案有哪些？","key":"javaScript16","answer":"解决方案：\n/*---------1.回调函数callback：----------*/\n被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数。如setTimeOut，ajax请求，readFile等。\n例：\n\nfunction greeting(name) {\n  alert('Hello ' + name);\n}\n\nfunction processUserInput(callback) {\n  var name = prompt('请输入你的名字。');\n  callback(name);\n}\n\nprocessUserInput(greeting);\n优点：\n解决了异步的问题。\n\n缺点：\n回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。\n\n/*---------2.事件发布订阅：---------*/\n当一个任务执行完成后，会发布一个事件，当这个事件有一个或多个‘订阅者’的时候，会接收到这个事件的发布，执行相应的任务，这种模式叫发布订阅模式。如node的events,dom的事件绑定\n例：\n\ndocument.body.addEventListener('click',function(){\n  alert('订阅了');\n},false);\ndocument.body.click(); \n优点：\n时间对象上的解耦。\n\n缺点：\n消耗内存，过度使用会使代码难以维护和理解\n\n/*---------3.Promise：---------*/\nPromise是es6提出的异步编程的一种解决方案。\nPromise 对象有三种状态：\n\npending: 初始状态，既不是成功，也不是失败状态。\nfulfilled: 意味着操作成功完成。\nrejected: 意味着操作失败。\npromise的状态只能从pending变成fulfilled，和pending变成rejected，状态一旦改变，就不会再改变，且只有异步操作的结果才能改变promise的状态。\n例：\nlet promise = new Promise(function (resolve, reject) {\n    fs.readFile('./1.txt', 'utf8', function (err, data) {\n        resolve(data)\n    })\n})\n\npromise\n    .then(function (data) {\n        console.log(data)\n    })\n优点：\n解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。\n\n缺点：\n无法取消promise。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。当执行多个Promise时，一堆then看起来也很不友好。\n\n/*---------4.Generator：---------*/\nGenerator是es6提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用yield语句。Generaotr函数会返回一个遍历器，可以进行遍历操作执行每个中断点yield。\n例：\n\nfunction * count() {\n  yield 1\n  yield 2\n  return 3\n}\nvar c = count()\nconsole.log(c.next()) // { value: 1, done: false }\nconsole.log(c.next()) // { value: 2, done: false }\nconsole.log(c.next()) // { value: 3, done: true }\nconsole.log(c.next()) // { value: undefined, done: true }\n优点：\n没有了Promise的一堆then(),异步操作更像同步操作，代码更加清晰。\n\n缺点：\n不能自动执行异步操作，需要写多个next()方法，需要配合使用Thunk函数和Co模块才能做到自动执行。\n\n\n/*---------5.async/await：---------*/\nasync是es2017引入的异步操作解决方案，可以理解为Generator的语法糖，async等同于Generator和co模块的封装，async 函数返回一个 Promise。\n例：\n\nasync function read() {\n let readA = await readFile('data/a.txt')\n let readB = await readFile('data/b.txt')\n let readC = await readFile('data/c.txt')\n\n console.log(readA)\n console.log(readB)\n console.log(readC)\n}\n\nread()\n优点：\n内置执行器，比Generator操作更简单。async/await比*yield语义更清晰。返回值是Promise对象，可以用then指定下一步操作。代码更整洁。可以捕获同步和异步的错误。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★★ async 和 await 、promise的区别 和 这两个的本质","key":"javaScript17","answer":"/*---------Promise概念：---------*/\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的\n\n/*---------async await概念：---------*/\nasync await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。\n\n两者的区别：\nPromise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。\n\nasync await与Promise一样，是非阻塞的。\n\nasync await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 简述 aync await 的好处","key":"javaScript18","answer":"1. async/await最重要的好处是同步编程风格\n2. async/await有本地浏览器支持。截至今天，所有主流浏览器 查看都完全支持异步功能。\n3. async关键字。它声明 getBooksByAuthorWithAwait()函数返回值确保是一个 promise，以便调用者可以安全调用 getBooksByAuthorWithAwait().then(...)或 await getBooksByAuthorWithAwait()"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★★ 移动端点击事件 300ms 延迟如何去掉？原因是什么？","key":"javaScript19","answer":"300毫秒原因：\n当用户第一次点击屏幕后，需要判断用户是否要进行双击操作，于是手机会等待300毫秒，\n解决方法：FastClick.js\nFastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ Cookie 有哪些属性？其中HttpOnly，Secure，Expire分别有什么作用？","key":"javaScript20","answer":"Cookie属性：\nname　　字段为一个cookie的名称。\nvalue　　字段为一个cookie的值。\ndomain　　字段为可以访问此cookie的域名。\npath　　字段为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。\nexpires/Max-Age 　　字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。\nSize　　字段 此cookie大小。\nhttp　　字段  cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。\nsecure　　 字段 设置是否只能通过https来传递此条cookie\n\n1 secure属性\n当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。\n2 HttpOnly属性\n如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。\n3 Expire属性\n设置Cookie的失效时间："},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★★★ 如何实现函数的柯里化？比如 add(1)(2)(3)","key":"javaScript21","answer":"/*-----解决方法1：-----*/\nfunction add () {\n  var args = Array.prototype.slice.call(arguments);\n\n  var fn = function () {\n    var sub_arg = Array.prototype.slice.call(arguments);\n　　 // 把全部的参数聚集到参数的入口为一个参数： args.concat(sub_arg)\n    return add.apply(null, args.concat(sub_arg));\n  }\n\n  fn.valueOf = function () {\n  return args.reduce(function(a, b) {\n      return a + b;\n    })\n  }\n\n  return fn;\n}\nconsole.log(add(1,2)) // 3\nconsole.log(add(1)(2)) // 3\nconsole.log(add(1)(2)(3)) // 6\nconsole.log(add(1,2,3)(4)) // 10\n\n/*-----解决方法2：-----*/\n\nfunction add () {\n    var args = Array.prototype.slice.call(arguments);\n\n    var fn = function () {\n        // 把参数都放在一个相当于全局变量的 args 里面　\n        args.push(...arguments)\n        return fn;\n    }\n\n    fn.valueOf = function () {\n        return args.reduce(function(a, b) {\n            return a + b;\n        })\n    }\n\n    return fn;\n}\nconsole.log(add(1,2)) // 3\nconsole.log(add(1)(2)) // 3\nconsole.log(add(1)(2)(3)) // 6\nconsole.log(add(1,2,3)(4)) // 10"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★★ 什么是反柯里化","key":"javaScript22","answer":"在JavaScript中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点。可以通过反柯里化(uncurrying)函数实现，让一个对象去借用一个原本不属于他的方法。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 将 [1,2] 与 [3,[4]] 合并为 [1,2,3,[4]]","key":"javaScript23","answer":"JS数组合并方法:\nlet arr3 = [1,2].concat([3,[4]]);    //[1,2,3,[4]]"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ Array.forEach() 与 Array.map() 的区别，Array.slice() 与 Array.splice() 的区别？","key":"javaScript24","answer":"/*-----forEach-----*/\nforEach不支持return,对原来的数组也没有影响。但是我们可以自己通过数组的索引来修改原来的数组\n\nvar ary = [12,23,24,42,1];\nvar res = ary.forEach(function (item,index,input) {\n     input[index] = item*10;\n})\nconsole.log(res);//-->undefined;\nconsole.log(ary);//-->会对原来的数组产生改变；\n/*-----map-----*/\nmap支持return返回值，也不影响原数组，但是会返回一个新的数组\n\nvar ary = [12,23,24,42,1];\nvar res = ary.map(function (item,index,input) {\n     return item*10;\n})\nconsole.log(res);//-->[120,230,240,420,10];\nconsole.log(ary);//-->[12,23,24,42,1]；\n\narray.slice(start,end)函数是取array数组中指定的一些元素：\n根据数组下标start和end，两个参数为取值的开始和结束下标，取出的值不包括end位置的值，生成一个新数组作为返回值；\n这里end可以为空，为空则取从start位置到数组结尾的元素，生成新数组。\n\narray.splice(start,length,insert_one......)函数则是直接在原数组进行删除、添加、替换元素的操作：\nstart为数组删除元素的开始下标，\nlength为从start位置开始array删除元素的个数，\n后面参数为删除之后array重新插入的数据内容，插入位置为删除位置，而非数组开头或末尾，\n返回值为array删除的元素组成的数组。\n显而易见，splice函数可以用来对数组元素进行替换。由splice操作后的数组array，数组中内容如果已经改变，就再也找不回array在splice之前的模样。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 将 1234567 转换为 1,234,567","key":"javaScript25","answer":"function fun(n){\n    return String(n).replace(/(?!^)(?=(\\d{3})+\\.)/g, \",\") \n}"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ bind 的作用是什么？","key":"javaScript26","answer":"bind()方法主要就是将函数绑定到某个对象，\nbind()会创建一个函数，函数体内的this对象的值会被绑定到传入bind()第一个参数的值"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ Promise.resolve(Promise.resolve(1)).then(console.log) 输出？","key":"javaScript27","answer":"1"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ var let const的区别","key":"javaScript28","answer":"1. var声明的变量会挂载在window上，而let和const声明的变量不会\n2. var声明变量存在变量提升，let和const不存在变量提升\n3. let和const声明形成块作用域\n4. 同一作用域下let和const不能声明同名变量，而var可以\n5. 使用let/const声明的变量在当前作用域存在暂存死区\n6. const一旦声明必须赋值,不能使用null占位,声明后不能再修改,如果声明的是复合类型数据，可以修改其属性"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ document load 和 documen ready的区别","key":"javaScript29","answer":"DOM文档解析：\n\n解析html结构\n加载脚本和样式文件\n解析并执行脚本\n构造html的DOM模型      //ready\n加载图片等外部资源文件\n页面加载完毕           //load\n\ndocument load:\nload是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数，load方法就是onload事件。\n\ndocumen ready:\n构造html的DOM模型加载完毕后触发"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 如何自定义事件？","key":"javaScript30","answer":"自定义事件\n事件是与DOM交互的最常见的方式。通过实现自定义事件，可以让事件用于非DOM代码中。\n思想：创建一个管理事件的对象，让其他对象监听那些事件。\n\n基本模式：\n\nfunction EventTarget(){\n    this.handlers = {};\n}\n\nEventTarget.prototype = {\n    constructor:EventTarget,\n    addHandler:function(type,handler){\n        if(typeof this.handlers[type] === \"undefined\"){\n            this.handlers[type] = [];\n        }\n        this.handlers[type].push(handler);\n    },\n    fire:function(event){\n        if(!event.target){\n            event.target = this;\n        }\n        if(this.handlers[event.type] instanceof Array){\n            const handlers = this.handlers[event.type];\n            handlers.forEach((handler)=>{\n                handler(event);\n            })\n        }\n    },\n    removeHandler:function(type,handler){\n        if(this.handlers[type] instanceof Array){\n            const handlers = this.handlers[type];\n            for(var i = 0,len = handlers.length; i < len; i++){\n                if(handlers[i] === handler){\n                    break;\n                }\n            }\n            handlers.splice(i,1);\n        }\n    }\n}"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 如何用 setTImeout 来实现 setInterval？","key":"javaScript31","answer":"1.不去关心回调函数是否还在运行\n在某些情况下，函数可能需要比间隔时间更长的时间去完成执行。比如说是用setInterval每隔5秒对远端服务器进行轮询，网络延迟，服务器无响应以及其他因素将会阻止请求按时按成。结果会导致返回一串无必要的排成队列请求。\n\n2.忽视错误\n因为某些原因，setInterval调用的代码中会出现一个错误，但是代码并不会中止执行而是继续执行错误的代码。\n\n3.缺乏灵活性\n除了前面提到的缺点之外，我非常希望setInterval方法能有一个表明执行次数的参数而不是无休止的执行下去。\n\nfunction interval(func, w, t){\n    var interv = function(){\n        if(typeof t === \"undefined\" || t-- > 0){\n            setTimeout(interv, w);\n            try{\n                func.call(null);\n            }\n            catch(e){\n                t = 0;\n                throw e.toString();\n            }\n        }\n    };\n    setTimeout(interv, w);\n};"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★★ 如何判断 user 对象里有没有 a 这个属性？如果把user对象中所有的属性都输出出来？","key":"javaScript32","answer":"(var user = {'a': '19', 'b': '18', 'c': '16'})\n\n\n\n\n如何判断 user 对象里有没有 a 这个属性？\n\njs对象的Object.hasOwnProperty()方法\n返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n\nlet obj = new Object();\nobj.a = \"123\";\nconsole.log(obj.hasOwnProperty('a'))  // true\nconsole.log(obj.hasOwnProperty('b'))  // false\n\n把user对象中所有的属性都输出出来\nfor(item for user){\n    console.log(item)\n}\n"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 使用 setTimeout 模拟 setInterval 的功能做一个60秒的倒数计时","key":"javaScript33","answer":"function setInter(s,fn){\n  let timeOut = (s,fn)=>{\n      setTimeout(()=>{\n        fn();\n        timeOut(s,fn);\n      },s)\n  }\n  timeOut(s,fn);\n}\n\n//调用上面的方法\nsetInter(60000,()=>{console.log(\"hello world!\")})"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 实现一个函数 add()，运算结果可以满足如下预期结果","key":"javaScript34","answer":"function add () {\n  var args = Array.prototype.slice.call(arguments);\n\n  var fn = function () {\n    var sub_arg = Array.prototype.slice.call(arguments);\n　　 // 把全部的参数聚集到参数的入口为一个参数： args.concat(sub_arg)\n    return add.apply(null, args.concat(sub_arg));\n  }\n\n  fn.valueOf = function () {\n  return args.reduce(function(a, b) {\n      return a + b;\n    })\n  }\n\n  return fn;\n}\n\nadd(1,2,3)(10) //16\nadd(1)(2)(3,4)(5) //15"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★★ 如何避免回调地狱？","key":"javaScript35","answer":"1. Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。\n\npromise只有两个状态resolve和reject，当它触发任何一个状态后，它会将当前的值缓存起来，并在有回调函数添加进来的时候尝试调用回调函数，如果这个时候还没有触发resolve或者reject，那么回调函数会被缓存，等待调用，如果已经有了状态(resolve或者reject)，则立刻调用回调函数。并且所有回调函数在执行后都立即被销毁。\n\n2. ES6 co/yield方案\nyield: Generator 函数是协程在 ES6 的实现，而yield是 Generator关键字， 异步操作需要暂停的地方，都用yield语句注明。\nco: co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。\n\n3. ES7 async/await 方案\nasync/await是es7的新标准，并且在node7.0中已经得到支持。\n它就是 Generator 函数的语法糖，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。可以理解官方对co和Generator 封装方案。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 写一个 function，清除字符串前后的空格。（兼容所有的浏览器）","key":"javaScript36","answer":"function trim(str) {\n    if (str && typeof str === \"string\") {\n        return str.replace(/(^\\s*)|(\\s*)$/g,\"\"); //去除前后空白符\n    }\n}"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 使用正则表达式验证邮箱格式","key":"javaScript37","answer":"function fChkMail(emailAddress){ \n    var reg = new RegExp(\"^[a-z0-9]+([._\\\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+.){1,63}[a-z0-9]+$\"); \n    var bChk=reg.test(emailAddress); \n    return bChk; \n}"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★★ 简述同步和异步的区别","key":"javaScript38","answer":"同步：\n同步的思想是：所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，给用户一种卡死了的感觉（就是系统迁移中，点击了迁移，界面就不动了，但是程序还在执行，卡死了的感觉）。这种情况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。\n\n异步：\n将用户请求放入消息队列，并反馈给用户，系统迁移程序已经启动，你可以关闭浏览器了。然后程序再慢慢地去写入数据库去。这就是异步。但是用户没有卡死的感觉，会告诉你，你的请求系统已经响应了。你可以关闭界面了。\n\n同步和异步本身是相对的:\n同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。\n\n异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。\n\n存在就有其道理 异步虽然好 但是有些问题是要用同步用来解决，比如有些东西我们需要的是拿到返回的数据在进行操作的。这些是异步所无法解决的。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":" ★★ JavaScript 中 callee 和 caller 的作用","key":"javaScript39","answer":"1.callee\ncallee是对象的一个属性，该属性是一个指针，指向参数arguments对象的函数\n作用：就是用来指向当前对象\n返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文. \ncallee是arguments 的一个属性成员，它表示对函数对象本身的引用，这有利于匿名 \n函数的递归或者保证函数的封装性\n\n2.caller\ncaller是函数对象的一个属性，该属性保存着调用当前函数的函数的引用（指向当前函数的直接父函数）\n返回一个对函数的引用，该函数调用了当前函数。\nfunctionName.caller\nfunctionName 对象是所执行函数的名称。\n注意：\n对于函数来说，caller 属性只有在函数执行时才有定义。 如果函数是由 Javascript 程序的顶层调用的，那么 caller 包含的就是 null 。"},{"answerTimes":"","frequentProblems":"","rightAndWrongTimes":"","modify":"","name":"★★ 统计字符串中字母个数或统计最多的字母数","key":"javaScript40","answer":"function count(str) {\n  var obj = {}; // 统计对象\n  var i = 0;\n  var len = str.length;\n  for (; i < len; i++){\n    var curChar = str.charAt(i); \n    // 如果结果对象存在该字符的属性，则自增，否则置为1\n    if (obj[curChar]) {\n      obj[curChar]++;\n    } else {\n      obj[curChar] = 1;\n    }\n  }\n  // 返回结果\n  return obj;\n}\nvar str = \"javaScript\";\nconsole.log(count(str));"}],"isChoice":false}